Django 튜토리얼(1) - Channels를 이용한 실시간 채팅(2)

##############################################################################################

1. Room view 추가하기

    - 두 번째 view인 room view를 추가한다.
    room view에서는 특정 채팅방에서 메세지를 게시하게 된다.

    - chat/templates/chat/room.html에 새로운 파일을 생성해준다.
    chat 디렉토리는 다음과 같아진다.

-----------------------
chat/
    __init__.py
    templates/
        chat/
            index.html
            room.html
    urls.py
    views.py
-----------------------

    - view template의 생성을 위해 room.html을 다음과 같이 작성해 준다.

-----------------------------------------------------------------------------------
<!-- chat/templates/chat/room.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Chat Room</title>
</head>
<body>
    <textarea id="chat-log" cols="100" rows="20"></textarea><br>
    <input id="chat-message-input" type="text" size="100"><br>
    <input id="chat-message-submit" type="button" value="Send">
    {{ room_name|json_script:"room-name" }}
    <script>
        const roomName = JSON.parse(document.getElementById('room-name').textContent);

        const chatSocket = new WebSocket(
            'ws://'
            + window.location.host
            + '/ws/chat/'
            + roomName
            + '/'
        );

        chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            document.querySelector('#chat-log').value += (data.message + '\n');
        };

        chatSocket.onclose = function(e) {
            console.error('Chat socket closed unexpectedly');
        };

        document.querySelector('#chat-message-input').focus();
        document.querySelector('#chat-message-input').onkeyup = function(e) {
            if (e.keyCode === 13) {  // enter, return
                document.querySelector('#chat-message-submit').click();
            }
        };

        document.querySelector('#chat-message-submit').onclick = function(e) {
            const messageInputDom = document.querySelector('#chat-message-input');
            const message = messageInputDom.value;
            chatSocket.send(JSON.stringify({
                'message': message
            }));
            messageInputDom.value = '';
        };
    </script>
</body>
</html>
-----------------------------------------------------------------------------------

    - room view를 위해 view 함수를 chat/views.py에 작성해준다.

---------------------------------------------------
# chat/views.py

from django.shortcuts import render

def index(request):
    return render(request, 'chat/index.html', {})

def room(request, room_name):
    return render(request, 'chat/room.html', {
        'room_name': room_name
    })
---------------------------------------------------

    - room view에 대한 경로를 chat/urls.py에 작성해준다.

-------------------------------------------------------
# chat/urls.py

from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('<str:room_name>/', views.room, name='room'),
]
-------------------------------------------------------

    - Channels 개발 서버를 작동해보자.

$ python3 manage.py runserver

    - http://127.0.0.1:8000/chat/lobby/ 에서 채팅을 작성해도 아무일도 일어나지 않는다.

    -> room view에서는 URL(ws://127.0.0.1:8000/ws/chat/lobby/)에 대한 WebSocket을 열려고 하지만
    consumer를 생성하지 않았기 때문에, WebSocket이 연결되지 않는다.

    -> consumer를 통해 WebSocket에 대한 연결을 하는 것 같다.

WebSocket connection to 'ws://127.0.0.1:8000/ws/chat/lobby/' failed: Unexpected response code: 500

##############################################################################################

2. 첫번째 consumer 생성하기

    - Django가 HTTP 요청을 받아들이게 되면, 루트 URLconf를 참조하여 view함수를 조회하고, 요청을 처리하기 위한 view 함수를 호출한다.
    유사하게, Channels는 WebSocket 연결을 받아들이면, 루트 라우팅 구성을 참조하여 소비자를 조회하고, 연결에서 사건을 처리하기 위해
    소비자에 대한 다양한 함수를 호출한다.

    * HTTP 요청 -> Django : root URLconf를 참조하여 view function 조회 -> view 함수 호출 -> 요청 처리


    * WebSocket 연결 -> Channels : root routing configuration을 참조하여 consumer 조회 -> consumer에 대한 가양한 function 호출
    -> events from the connection 처리

    - 우선 /ws/chat/ROOM_NAME/의 경로로 연결되는 WebSocket 연결을 받아들이기 위한 기본적인 consumer 생성
    WebSocket을 통해 메시지를 받으면, 그대로 WebSocket으로 보내주는 메아리를 생성

    ** /ws/ 와 같은 형태의 경로에 대한 접두사를 사용하여 WebSocket과 일반 HTTP 연결을 구분하는 것은 좋다. 특정한 생성환경에서
    채널을 더 쉽게 배포할 수 있도록 해준다.

    - chat 디렉토리에 consumers.py 를 생성해 준다.

------------------------
chat/
    __init__.py
    consumers.py
    templates/
        chat/
            index.html
            room.html
    urls.py
    views.py
------------------------

    - chat/consumers.py에 다음과 같은 코드를 입력해 준다.

---------------------------------------------------------
# chat/consumers.py

import json
from channels.generic.websocket import WebsocketConsumer

class ChatConsumer(WebsocketConsumer):
    def connect(self):
        self.accept()

    def disconnect(self, close_code):
        pass

    def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']

        self.send(text_data=json.dumps({
            'message': message
        }))
---------------------------------------------------------

    - 위는 모든 연결에 대해서 허가하는 동기식 WebSocket으로 clients로 부터 메시지를 받고, 동일 client에게 메시지를 돌려주는 메아리를 한다.
    동일한 채팅방의 다른 clients 에게는 메시지가 전달되지 않는다.

    * Channels은 더 높은 성능을 위해 비동기 consumers를 사용하는 것을 지원한다. 그러나 비동기 consumers는 Django 모델에 액세스 하는 것
    과 같이 차단 작업을 직접 수행하지 않도록 주의해야 한다.

    - chat 어플리케이션에 consumer에 대한 경로를 포함한 라우팅 구성을 생성해 줘야 한다.

    - chat/routing.py 를 생성해 준다.

-----------------------
chat/
    __init__.py
    consumers.py
    routing.py
    templates/
        chat/
            index.html
            room.html
    urls.py
    views.py
-----------------------

    - chat/routing.py에는 다음과 같은 코드를 입력한다.

--------------------------------------------------------------------------------
# chat/routing.py

from django.urls import re_path

from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/chat/(?P<room_name>\w+)/$', consumers.ChatConsumer.as_asgi()),
]
--------------------------------------------------------------------------------

    - 각 사용자 연결에 대해서, 고비자의 인스턴스를 인스턴스화 하는 ASGI 어플리케이션을 얼기 위해, as_asgi() 클래스 매서드를 호출한다.
    이는 요청당(per-request) 보기 인스턴스에 대해서 동일한 역할을 하는 Django의 as_view()와 유사하다.

    -> 이때 URL 라우터의 제한으로 인해 re_path()를 사용한다.

    - 다음으로는 root routing configuration이 chat.routing 모듈을 항하도록 만들어 준다.

    - mysite/asgi.py에 AuthMiddlewareStack, URLRouter, chat.routing 를 임포트 해주고,
    ProtocolTypeRouter 리스트의 key값 'websocket'에 대해서 다음과 같이 추가해준다.

---------------------------------------------------------------------
# mysite/asgi.py

import os

from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from django.core.asgi import get_asgi_application
import chat.routing

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "mysite.settings")

application = ProtocolTypeRouter({
  "http": get_asgi_application(),
  "websocket": AuthMiddlewareStack(
        URLRouter(
            chat.routing.websocket_urlpatterns
        )
    ),
})
---------------------------------------------------------------------

    - 위의 root routing configuration은 Channels 개발 서버에 연결할 때, 프로토콜 유형 경로가 먼저 연결 유형을 검사하도록 지정한다.
    WebSocket 연결(ws:// 또는 wss://)인 경우, AuthMiddlewareStack에 연결된다.

    - AuthMiddlewareStack은 Django의 AuthenticationMiddleware가 View 함수의 목표 요청을 현재 인등된 사용자에게 전달하는 것과 유사하게,
    연결 범위를 현재 인증된 사용자에 대한 참조로 채운다. 그리고 이 연결은  URLRouter로 전달된다.

    - URLRouter는 제공된 URL 패턴에 기초하여 특정 소비자로의 경로를 연결하기 위해 HTTP 경로를 검사한다.

    - /ws/chat/ROOM_NAME/ 경로에 대한 전기 소비 장치가 작동하는지 확인하고, migrations을 실행하여 데이터베이스의 변경사항들을
    적용하고 채널 개발 서버를 시작한다.

------------------------------------------------------------
$ python manage.py migrate

Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK

$ python3 manage.py runserver

------------------------------------------------------------

    -  http://127.0.0.1:8000/chat/lobby/ 를 통해 "hello"를 입력하면, 그대로 로그에 "hello"를 확인할 수 있다.

    - 여기서 다른 브라우저를 통해 같은 채팅방에 들어가서 메시지를 입력하면, 첫 번째 탭에서 메시지를 확인할 수 없다.

    -> 최종적으로 동일한 Chat consumer들이 서로 대화를 할 수 있도록 만들어야 한다.
    채널은 소비자들 사이의 이런 종류의 통신을 가능하게 하는 channel layer abstraction을 제공한다.

##############################################################################################

3. Channel layer 가능하게 하기




##############################################################################################





##############################################################################################















